<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Boxing - Living Room Edition</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #000; }
        
        /* Main 3D Container */
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI Layer */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        
        /* Camera Preview (Top Left) */
        #preview-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 240px;
            height: 180px;
            background: #222;
            border: 4px solid #fff;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 16px rgba(0,0,0,0.5);
            z-index: 10;
        }
        
        /* Mirror the video for natural feel */
        #input_video { width: 100%; height: 100%; object-fit: cover; display: none; } 
        #output_canvas { width: 100%; height: 100%; display: block; }
        
        /* Score Display */
        #score-board {
            position: absolute;
            top: 20px;
            right: 30px;
            text-align: right;
        }
        #score-label { font-size: 18px; color: #888; font-weight: bold; text-transform: uppercase; }
        #score-value { font-size: 64px; color: #ff4757; font-weight: 900; text-shadow: 2px 2px 0px #fff; margin-top: -10px; }
        
        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            font-size: 24px;
            color: #333;
            text-shadow: 0 1px 0 rgba(255,255,255,0.8);
        }
        
        /* Loading Screen */
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #f1f2f6; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100;
        }
        .spinner {
            width: 50px; height: 50px; border: 5px solid #ccc; border-top-color: #ff4757;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Customization Panel */
        #customization-panel {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 12px;
            color: white; text-align: center; pointer-events: auto;
            border: 1px solid #555;
        }
        .color-btn {
            width: 30px; height: 30px; border-radius: 50%; border: 2px solid #fff;
            margin: 5px; cursor: pointer; display: inline-block; transition: transform 0.1s;
        }
        .color-btn:hover { transform: scale(1.1); }
        .shape-btn {
            background: #444; color: #fff; border: 1px solid #fff; border-radius: 4px;
            padding: 5px 10px; margin: 5px; cursor: pointer; font-family: inherit;
        }
        .shape-btn:hover { background: #666; }

        /* About Section */
        #about-section {
            position: absolute; bottom: 20px; left: 20px;
            color: #888; font-size: 14px; font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }
    </style>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        <div class="spinner"></div>
        <h2>Loading AI Models...</h2>
        <p>Please allow camera access when prompted.</p>
    </div>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="preview-container">
            <video id="input_video"></video>
            <canvas id="output_canvas"></canvas>
        </div>
        
        <div id="score-board">
            <div id="score-label">Score</div>
            <div id="score-value">0</div>
        </div>
        
        <div id="instructions">
            Stand sideways, facing Right, and <b>PUNCH</b> the bag!
        </div>

        <div id="customization-panel">
            <div style="margin-bottom: 5px; font-weight: bold; font-size: 14px;">COLOR</div>
            <div>
                <div class="color-btn" style="background: #7f8fa6" onclick="setCharColor(0x7f8fa6)"></div>
                <div class="color-btn" style="background: #e74c3c" onclick="setCharColor(0xe74c3c)"></div>
                <div class="color-btn" style="background: #2ecc71" onclick="setCharColor(0x2ecc71)"></div>
                <div class="color-btn" style="background: #f1c40f" onclick="setCharColor(0xf1c40f)"></div>
            </div>
            <div style="margin: 10px 0 5px; font-weight: bold; font-size: 14px;">BODY SHAPE</div>
            <div>
                <button class="shape-btn" onclick="setBodyShape(0.6)">Slim</button>
                <button class="shape-btn" onclick="setBodyShape(1.0)">Avg</button>
                <button class="shape-btn" onclick="setBodyShape(1.5)">Buff</button>
            </div>
        </div>

        <div id="about-section">
            Made by Darshan.S
        </div>
    </div>

<script>
    // --- Game State ---
    let score = 0;
    let lastHitTime = 0;
    const HIT_COOLDOWN = 150; // ms
    
    // --- Three.js Setup ---
    const container = document.getElementById('game-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf1f2f6); // Light grey/white
    scene.fog = new THREE.Fog(0xf1f2f6, 5, 15);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(3.5, 1.6, -0.5); // Side view
    camera.lookAt(0, 1.2, -0.5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // --- Lighting ---
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    scene.add(dirLight);

    // --- Environment: Living Room ---
    // Floor
    const floorGeo = new THREE.PlaneGeometry(20, 20);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0xd1ccc0, roughness: 0.8 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Walls
    const wallMat = new THREE.MeshStandardMaterial({ color: 0xf7f1e3 }); // Cream
    const backWall = new THREE.Mesh(new THREE.BoxGeometry(20, 10, 1), wallMat);
    backWall.position.set(0, 5, -5);
    backWall.receiveShadow = true;
    scene.add(backWall);

    const leftWall = new THREE.Mesh(new THREE.BoxGeometry(1, 10, 20), wallMat);
    leftWall.position.set(-10, 5, 0);
    scene.add(leftWall);

    const rightWall = new THREE.Mesh(new THREE.BoxGeometry(1, 10, 20), wallMat);
    rightWall.position.set(10, 5, 0);
    scene.add(rightWall);

    // Artifacts
    // Shelf
    const shelf = new THREE.Mesh(new THREE.BoxGeometry(4, 0.2, 1), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
    shelf.position.set(-4, 2, -4.4);
    shelf.castShadow = true;
    scene.add(shelf);

    // Vase on shelf
    const vase = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 0.8, 16), new THREE.MeshStandardMaterial({ color: 0x3498db }));
    vase.position.set(-3.5, 2.5, -4.4);
    vase.castShadow = true;
    scene.add(vase);

    // Painting
    const paintingFrame = new THREE.Mesh(new THREE.BoxGeometry(2, 3, 0.1), new THREE.MeshStandardMaterial({ color: 0x2c3e50 }));
    paintingFrame.position.set(4, 3, -4.45);
    scene.add(paintingFrame);
    const paintingCanvas = new THREE.Mesh(new THREE.PlaneGeometry(1.8, 2.8), new THREE.MeshBasicMaterial({ color: 0xe17055 })); // Abstract art
    paintingCanvas.position.set(4, 3, -4.39);
    scene.add(paintingCanvas);

    // --- Punching Bags ---
    const bagInstances = [];
    const pivotY = 4;
    const chainLen = 2.0;
    const bagHeight = 1.2;
    const bagRadius = 0.35;

    function createBag(zPos) {
        const group = new THREE.Group();
        group.position.set(0, pivotY, zPos);
        scene.add(group);

        const chain = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, chainLen), new THREE.MeshStandardMaterial({ color: 0x2f3542 }));
        chain.position.y = -chainLen / 2;
        group.add(chain);

        const bag = new THREE.Mesh(new THREE.CylinderGeometry(bagRadius, bagRadius, bagHeight, 32), new THREE.MeshStandardMaterial({ color: 0xc0392b, roughness: 0.4 }));
        bag.position.y = -chainLen - (bagHeight / 2);
        bag.castShadow = true;
        group.add(bag);

        bagInstances.push({ group, mesh: bag, angleX: 0, angleZ: 0, velX: 0, velZ: 0 });
    }

    createBag(-0.9); // Front bag
    createBag(0.9);  // Back bag

    // --- Player Character (Robot/Mannequin) ---
    const playerGroup = new THREE.Group();
    scene.add(playerGroup);

    const jointMat = new THREE.MeshStandardMaterial({ color: 0x2f3640 });
    const limbMat = new THREE.MeshStandardMaterial({ color: 0x7f8fa6 });
    const gloveMat = new THREE.MeshStandardMaterial({ color: 0xe1b12c, roughness: 0.2 });

    // Customization State
    let bodyThickness = 1.0;

    window.setCharColor = function(hex) {
        limbMat.color.setHex(hex);
    };

    window.setBodyShape = function(scale) {
        bodyThickness = scale;
        // Scale static parts (Joints, Head, Torso, Gloves)
        [charParts.head, charParts.torso, 
         charParts.leftShoulder, charParts.rightShoulder, 
         charParts.leftElbow, charParts.rightElbow,
         charParts.leftWrist, charParts.rightWrist].forEach(p => p.scale.setScalar(scale));
    };

    function createLimb(radius, length) {
        const mesh = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, length, 16), limbMat);
        mesh.castShadow = true;
        return mesh;
    }

    function createJoint(radius) {
        return new THREE.Mesh(new THREE.SphereGeometry(radius), jointMat);
    }

    // Simple structure to hold references
    const charParts = {
        head: new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.3, 0.25), limbMat),
        torso: new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.1, 0.6), limbMat),
        leftShoulder: createJoint(0.08),
        rightShoulder: createJoint(0.08),
        leftElbow: createJoint(0.07),
        rightElbow: createJoint(0.07),
        leftWrist: new THREE.Mesh(new THREE.SphereGeometry(0.12), gloveMat), // Glove
        rightWrist: new THREE.Mesh(new THREE.SphereGeometry(0.12), gloveMat), // Glove
        // Connectors
        leftUpperArm: createLimb(0.05, 1),
        rightUpperArm: createLimb(0.05, 1),
        leftLowerArm: createLimb(0.04, 1),
        rightLowerArm: createLimb(0.04, 1)
    };

    // Add parts to group
    Object.values(charParts).forEach(part => playerGroup.add(part));

    // Helper to orient cylinders between two points
    function placeCylinder(cylinder, point1, point2) {
        const mid = new THREE.Vector3().addVectors(point1, point2).multiplyScalar(0.5);
        cylinder.position.copy(mid);
        cylinder.lookAt(point2);
        cylinder.rotateX(Math.PI / 2);
        const dist = point1.distanceTo(point2);
        cylinder.scale.set(bodyThickness, dist, bodyThickness); // Scale Y to match distance, X/Z for thickness
    }

    // --- Audio ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playHitSound() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    }

    // --- MediaPipe Setup ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');

    function onResults(results) {
        // 1. Draw Preview
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        if (results.poseLandmarks) {
            drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, results.poseLandmarks, {color: '#FF0000', lineWidth: 1, radius: 3});
        }
        canvasCtx.restore();

        // 2. Update 3D Character
        if (results.poseWorldLandmarks) {
            updateCharacter(results.poseWorldLandmarks);
        }

        // Hide loading screen on first success
        document.getElementById('loading').style.display = 'none';
    }

    const pose = new Pose({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
    }});
    pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    pose.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await pose.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    cameraUtils.start();

    // --- Game Logic ---

    // Map MediaPipe World Coordinates (Meters, Hip-centered) to Three.js World
    function mpToThree(lm) {
        // Sideways Mapping:
        // User facing Right in camera -> Character facing -Z (Bag)
        // MP X+ (Right) -> Game Z- (Forward)
        // MP Y+ (Down)  -> Game Y- (Down)
        // MP Z  (Depth) -> Game X  (Left/Right)
        return new THREE.Vector3(-lm.z, -lm.y, -lm.x);
    }

    function updateCharacter(landmarks) {
        // Landmarks: 11(L_Shoulder), 12(R_Shoulder), 13(L_Elbow), 14(R_Elbow), 15(L_Wrist), 16(R_Wrist)
        // 0 (Nose)
        
        // Offset to place character in front of camera
        const offset = new THREE.Vector3(0, 1.0, 0); // Lift up hips

        const nose = mpToThree(landmarks[0]).add(offset);
        const lShoulder = mpToThree(landmarks[12]).add(offset);
        const rShoulder = mpToThree(landmarks[11]).add(offset);
        const lElbow = mpToThree(landmarks[14]).add(offset);
        const rElbow = mpToThree(landmarks[13]).add(offset);
        const lWrist = mpToThree(landmarks[16]).add(offset);
        const rWrist = mpToThree(landmarks[15]).add(offset);

        // Update Mesh Positions
        charParts.head.position.copy(nose);
        charParts.leftShoulder.position.copy(lShoulder);
        charParts.rightShoulder.position.copy(rShoulder);
        charParts.leftElbow.position.copy(lElbow);
        charParts.rightElbow.position.copy(rElbow);
        charParts.leftWrist.position.copy(lWrist);
        charParts.rightWrist.position.copy(rWrist);

        // Update Connectors
        placeCylinder(charParts.leftUpperArm, lShoulder, lElbow);
        placeCylinder(charParts.rightUpperArm, rShoulder, rElbow);
        placeCylinder(charParts.leftLowerArm, lElbow, lWrist);
        placeCylinder(charParts.rightLowerArm, rElbow, rWrist);

        // Torso (Simple line between shoulders and hips approx)
        const midShoulder = new THREE.Vector3().addVectors(lShoulder, rShoulder).multiplyScalar(0.5);
        charParts.torso.position.copy(midShoulder).add(new THREE.Vector3(0, -0.3, 0));

        // --- Collision Detection ---
        // Convert local positions to world space for collision check (due to playerGroup rotation)
        const lWristWorld = lWrist.clone().add(playerGroup.position);
        const rWristWorld = rWrist.clone().add(playerGroup.position);
        
        checkCollision(lWristWorld, 'left');
        checkCollision(rWristWorld, 'right');
    }

    function checkCollision(glovePos, hand) {
        bagInstances.forEach(bagState => {
            // Calculate bag center based on pendulum angles
            const bagLen = chainLen + bagHeight/2;
            const bagX = bagState.group.position.x + Math.sin(bagState.angleZ) * bagLen;
            const bagZ = bagState.group.position.z + Math.sin(bagState.angleX) * bagLen;
            const bagY = bagState.group.position.y - Math.cos(bagState.angleZ) * Math.cos(bagState.angleX) * bagLen;
            
            const bagCenter = new THREE.Vector3(bagX, bagY, bagZ);
            
            // Distance check
            const dist = glovePos.distanceTo(bagCenter);
            const hitThreshold = bagRadius + 0.15; // Bag radius + Glove radius

            if (dist < hitThreshold) {
                const now = Date.now();
                if (now - lastHitTime > HIT_COOLDOWN) {
                    // HIT!
                    lastHitTime = now;
                    score += 10;
                    document.getElementById('score-value').innerText = score;
                    playHitSound();

                    // Apply Physics Impulse
                    // Direction from glove to bag
                    const forceDir = new THREE.Vector3().subVectors(bagCenter, glovePos).normalize();
                    
                    // Add velocity to pendulum angles
                    bagState.velX -= forceDir.z * 0.1; 
                    bagState.velZ -= forceDir.x * 0.1;
                    
                    // Visual flash
                    bagState.mesh.material.color.setHex(0xffffff);
                    setTimeout(() => bagState.mesh.material.color.setHex(0xc0392b), 100);
                }
            }
        });
    }

    // --- Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);

        // Bag Physics (Damped Pendulum)
        const gravity = 0.03;
        const damping = 0.95;

        bagInstances.forEach(bagState => {
            // Acceleration towards 0
            const accelX = -gravity * Math.sin(bagState.angleX);
            const accelZ = -gravity * Math.sin(bagState.angleZ);

            bagState.velX += accelX;
            bagState.velZ += accelZ;

            bagState.velX *= damping;
            bagState.velZ *= damping;

            bagState.angleX += bagState.velX;
            bagState.angleZ += bagState.velZ;

            // Apply rotation to bag group
            bagState.group.rotation.x = bagState.angleX;
            bagState.group.rotation.z = -bagState.angleZ; // Invert Z for correct visual swing
        });

        renderer.render(scene, camera);
    }

    // Handle Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>
